"""
Marshmallow schemas for UserTenantAssociation model validation and serialization.

This module provides schemas for managing user-tenant associations with role-based
access control. UserTenantAssociation is a many-to-many relationship between Users
and Tenants that includes role information.

Schemas provided:
- UserTenantAssociationSchema: Base schema with all fields
- UserTenantAssociationCreateSchema: For adding users to tenants (POST /api/tenants/{id}/users)
- UserTenantAssociationUpdateSchema: For updating user roles (PUT /api/tenants/{id}/users/{user_id})
- UserTenantAssociationResponseSchema: For API responses (all dump_only)

Role-Based Access Control:
- admin: Full access - can manage tenant, users, and all resources
- user: Standard access - can create/read/update/delete own resources
- viewer: Read-only access - can only view resources

Key Features:
- Role validation with predefined roles (admin, user, viewer)
- Composite primary key (user_id, tenant_id) prevents duplicates
- Role hierarchy for permission checks (admin > user > viewer)
- Automatic timestamp when user joins tenant

Pre-instantiated schema instances are provided at the bottom of this file for
convenient import and use in routes and services.

Usage:
    from app.schemas import user_tenant_association_create_schema, user_tenant_association_response_schema

    # Validate input for adding user to tenant
    data = user_tenant_association_create_schema.load(request.json)

    # Serialize output
    result = user_tenant_association_response_schema.dump(association)
"""

from marshmallow import Schema, fields, validates, ValidationError, post_load, validate
import logging

logger = logging.getLogger(__name__)

# Valid roles (must match UserTenantAssociation model)
ROLE_ADMIN = 'admin'
ROLE_USER = 'user'
ROLE_VIEWER = 'viewer'
VALID_ROLES = [ROLE_ADMIN, ROLE_USER, ROLE_VIEWER]


class UserTenantAssociationSchema(Schema):
    """
    Base schema for UserTenantAssociation model with all fields.

    This schema includes all fields from the UserTenantAssociation model and can be
    used as a reference or extended for specific use cases.

    Fields:
        user_id: UUID of user (part of composite primary key, dump_only)
        tenant_id: UUID of tenant (part of composite primary key, dump_only)
        role: User's role in tenant (required, one of: 'admin', 'user', 'viewer')
        joined_at: UTC timestamp when user joined tenant (auto-generated, dump_only)

    Role Hierarchy:
        admin > user > viewer
        - Admin: Can manage tenant, users, and all resources
        - User: Can create/read/update/delete own resources
        - Viewer: Read-only access to resources

    Example output:
        {
            "user_id": "123e4567-e89b-12d3-a456-426614174000",
            "tenant_id": "456e7890-e89b-12d3-a456-426614174001",
            "role": "admin",
            "joined_at": "2024-01-01T00:00:00Z"
        }
    """
    user_id = fields.UUID(dump_only=True)
    tenant_id = fields.UUID(dump_only=True)
    role = fields.Str(required=True, validate=validate.OneOf(VALID_ROLES))
    joined_at = fields.DateTime(dump_only=True)

    @validates('role')
    def validate_role(self, value, **kwargs):
        """
        Validate role is one of the allowed values.

        Rules:
        - Must be one of: 'admin', 'user', 'viewer'
        - Case-sensitive (must be lowercase)

        Args:
            value: The role to validate

        Raises:
            ValidationError: If role is not valid
        """
        if value not in VALID_ROLES:
            raise ValidationError(
                f"Invalid role: {value}. Must be one of: {', '.join(VALID_ROLES)}"
            )

        logger.debug(f"Validated role: {value}")

    @post_load
    def normalize_data(self, data, **kwargs):
        """
        Normalize input data after validation.

        Transformations:
        - Trim whitespace from role
        - Convert role to lowercase

        Args:
            data: The validated data dictionary

        Returns:
            Normalized data dictionary
        """
        if 'role' in data:
            data['role'] = data['role'].strip().lower()
            logger.debug(f"Normalized role: {data['role']}")

        return data


class UserTenantAssociationCreateSchema(Schema):
    """
    Schema for adding users to tenants (POST /api/tenants/{tenant_id}/users).

    This schema is used when an admin adds a user to a tenant with a specific role.
    The user_id comes from the request body, while tenant_id comes from the URL path.

    Required fields:
        user_id: UUID of user to add to tenant
        role: Role to assign ('admin', 'user', or 'viewer')

    Auto-generated fields (not included in input):
        joined_at: Timestamp (auto-generated by database)

    Business rules:
    - Only admin users can add users to tenants
    - Cannot add same user to tenant twice (composite key constraint)
    - User and tenant must exist in database
    - Default role for tenant creator is 'admin'

    Example request:
        POST /api/tenants/{tenant_id}/users
        {
            "user_id": "123e4567-e89b-12d3-a456-426614174000",
            "role": "user"
        }
    """
    user_id = fields.UUID(required=True)
    role = fields.Str(required=True, validate=validate.OneOf(VALID_ROLES))

    @validates('role')
    def validate_role(self, value, **kwargs):
        """
        Validate role is one of the allowed values.

        Rules:
        - Must be one of: 'admin', 'user', 'viewer'
        - Case-sensitive (must be lowercase)

        Args:
            value: The role to validate

        Raises:
            ValidationError: If role is not valid
        """
        if value not in VALID_ROLES:
            raise ValidationError(
                f"Invalid role: {value}. Must be one of: {', '.join(VALID_ROLES)}"
            )

        logger.debug(f"Validated role for association creation: {value}")

    @post_load
    def normalize_data(self, data, **kwargs):
        """
        Normalize input data after validation.

        Transformations:
        - Trim whitespace from role
        - Convert role to lowercase

        Args:
            data: The validated data dictionary

        Returns:
            Normalized data dictionary
        """
        if 'role' in data:
            data['role'] = data['role'].strip().lower()
            logger.debug(f"Normalized role for association creation: {data['role']}")

        return data


class UserTenantAssociationUpdateSchema(Schema):
    """
    Schema for updating user roles in tenants (PUT /api/tenants/{tenant_id}/users/{user_id}).

    This schema is used when an admin updates a user's role within a tenant.
    Only the role can be updated; user_id and tenant_id are immutable (part of primary key).

    Required fields:
        role: New role to assign ('admin', 'user', or 'viewer')

    Immutable fields (cannot be updated):
        user_id: Cannot change user association
        tenant_id: Cannot move user to different tenant
        joined_at: Audit trail immutable

    Business rules:
    - Only admin users can update roles
    - Cannot update non-existent associations
    - Cannot remove last admin from tenant
    - Role hierarchy: admin > user > viewer

    Use cases:
    - Promote user to admin: Update role to 'admin'
    - Demote admin to user: Update role to 'user'
    - Restrict user to viewer: Update role to 'viewer'

    Example request:
        PUT /api/tenants/{tenant_id}/users/{user_id}
        {
            "role": "admin"
        }
    """
    role = fields.Str(required=True, validate=validate.OneOf(VALID_ROLES))

    @validates('role')
    def validate_role(self, value, **kwargs):
        """
        Validate role is one of the allowed values.

        Rules:
        - Must be one of: 'admin', 'user', 'viewer'
        - Case-sensitive (must be lowercase)

        Args:
            value: The role to validate

        Raises:
            ValidationError: If role is not valid
        """
        if value not in VALID_ROLES:
            raise ValidationError(
                f"Invalid role: {value}. Must be one of: {', '.join(VALID_ROLES)}"
            )

        logger.debug(f"Validated role for association update: {value}")

    @post_load
    def normalize_data(self, data, **kwargs):
        """
        Normalize input data after validation.

        Transformations:
        - Trim whitespace from role
        - Convert role to lowercase

        Args:
            data: The validated data dictionary

        Returns:
            Normalized data dictionary
        """
        if 'role' in data:
            data['role'] = data['role'].strip().lower()
            logger.debug(f"Normalized role for association update: {data['role']}")

        return data


class UserTenantAssociationResponseSchema(Schema):
    """
    Schema for serializing UserTenantAssociation objects in API responses.

    This schema is used for all API responses that return user-tenant association data.
    All fields are dump_only (read-only) since this is purely for output.

    Fields included:
        user_id: User UUID
        tenant_id: Tenant UUID
        role: User's role in tenant ('admin', 'user', or 'viewer')
        joined_at: When user was added to tenant

    Optional nested data (not always included):
        user: Nested user object with basic info (email, name)
        tenant: Nested tenant object with basic info (name, database_name)

    Example output:
        {
            "user_id": "123e4567-e89b-12d3-a456-426614174000",
            "tenant_id": "456e7890-e89b-12d3-a456-426614174001",
            "role": "admin",
            "joined_at": "2024-01-01T00:00:00Z"
        }

    Example with nested data:
        {
            "user_id": "123e4567-e89b-12d3-a456-426614174000",
            "tenant_id": "456e7890-e89b-12d3-a456-426614174001",
            "role": "admin",
            "joined_at": "2024-01-01T00:00:00Z",
            "user": {
                "email": "user@example.com",
                "first_name": "John",
                "last_name": "Doe"
            },
            "tenant": {
                "name": "Acme Corporation",
                "database_name": "tenant_acme_corp_a1b2c3d4"
            }
        }
    """
    user_id = fields.UUID(dump_only=True)
    tenant_id = fields.UUID(dump_only=True)
    role = fields.Str(dump_only=True)
    joined_at = fields.DateTime(dump_only=True)

    # Optional nested fields (not always included)
    user = fields.Dict(dump_only=True)
    tenant = fields.Dict(dump_only=True)


# Pre-instantiated schema instances for convenient import
# These can be imported and used directly in routes and services

# Base schema (rarely used directly)
user_tenant_association_schema = UserTenantAssociationSchema()

# Input validation schemas
user_tenant_association_create_schema = UserTenantAssociationCreateSchema()
user_tenant_association_update_schema = UserTenantAssociationUpdateSchema()

# Output serialization schemas
user_tenant_association_response_schema = UserTenantAssociationResponseSchema()

# For serializing lists of associations
user_tenant_associations_response_schema = UserTenantAssociationResponseSchema(many=True)


# Export all schemas and instances
__all__ = [
    # Schema classes
    'UserTenantAssociationSchema',
    'UserTenantAssociationCreateSchema',
    'UserTenantAssociationUpdateSchema',
    'UserTenantAssociationResponseSchema',

    # Pre-instantiated schema instances
    'user_tenant_association_schema',
    'user_tenant_association_create_schema',
    'user_tenant_association_update_schema',
    'user_tenant_association_response_schema',
    'user_tenant_associations_response_schema',

    # Role constants
    'ROLE_ADMIN',
    'ROLE_USER',
    'ROLE_VIEWER',
    'VALID_ROLES',
]
